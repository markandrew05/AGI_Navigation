<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/aginavigation/ui/routes/RouteDetailFragment.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/aginavigation/ui/routes/RouteDetailFragment.kt" />
              <option name="originalContent" value="package com.example.aginavigation.ui.routes&#10;&#10;import android.os.Bundle&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.Button&#10;import android.widget.ImageButton&#10;import android.widget.TextView&#10;import android.widget.LinearLayout&#10;import android.widget.FrameLayout&#10;import androidx.fragment.app.Fragment&#10;import androidx.navigation.fragment.findNavController&#10;import com.example.aginavigation.R&#10;import com.example.aginavigation.data.RouteRenderConfig&#10;import com.google.android.gms.maps.CameraUpdateFactory&#10;import com.google.android.gms.maps.GoogleMap&#10;import com.google.android.gms.maps.OnMapReadyCallback&#10;import com.google.android.gms.maps.SupportMapFragment&#10;import com.google.android.gms.maps.model.BitmapDescriptorFactory&#10;import com.google.android.gms.maps.model.LatLng&#10;import com.google.android.gms.maps.model.LatLngBounds&#10;import com.google.android.gms.maps.model.MarkerOptions&#10;import com.google.android.gms.maps.model.PolylineOptions&#10;import androidx.core.graphics.toColorInt&#10;&#10;class RouteDetailFragment : Fragment(), OnMapReadyCallback {&#10;&#10;    private var googleMap: GoogleMap? = null&#10;    private var routePoints: ArrayList&lt;LatLng&gt;? = null&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater,&#10;        container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View? {&#10;        return inflater.inflate(R.layout.fragment_route_detail, container, false)&#10;    }&#10;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        super.onViewCreated(view, savedInstanceState)&#10;&#10;&#10;        val btnBack: ImageButton = view.findViewById(R.id.btnBack)&#10;        btnBack.setOnClickListener { findNavController().navigateUp() }&#10;&#10;        val btnStart: Button = view.findViewById(R.id.btnStartNavigation)&#10;        btnStart.setOnClickListener {&#10;            // Placeholder - start navigation later&#10;            findNavController().navigateUp()&#10;        }&#10;&#10;        // Retrieve route points if provided&#10;        @Suppress(&quot;DEPRECATION&quot;)&#10;        routePoints = arguments?.getParcelableArrayList(&quot;route_points&quot;)&#10;&#10;        val btnViewFull: Button? = view.findViewById(R.id.btnViewFullMap)&#10;        btnViewFull?.setOnClickListener {&#10;            // Open the fullscreen MapFragment and pass the same points&#10;            val bundle = Bundle().apply { putParcelableArrayList(&quot;route_points&quot;, routePoints) }&#10;            findNavController().navigate(R.id.navigation_map, bundle)&#10;        }&#10;&#10;        // Retrieve and display route name, summary and fare&#10;        val routeName = arguments?.getString(&quot;destinationName&quot;)&#10;        val routeSummary = arguments?.getString(&quot;routeSummary&quot;)&#10;        val routeFare = arguments?.getString(&quot;routeFare&quot;)&#10;&#10;        // Update the UI with route information&#10;        view.findViewById&lt;TextView&gt;(R.id.tvRouteName)?.text = routeName ?: &quot;Route Details&quot;&#10;        view.findViewById&lt;TextView&gt;(R.id.tvSummary)?.text = routeSummary ?: &quot;No description available&quot;&#10;        view.findViewById&lt;TextView&gt;(R.id.tvFareValue)?.text = routeFare ?: &quot;N/A&quot;&#10;&#10;        // Retrieve and display route detail info if available&#10;        @Suppress(&quot;DEPRECATION&quot;)&#10;        val routeInfo = arguments?.getSerializable(&quot;route_detail_info&quot;) as? RouteDetailInfo&#10;        if (routeInfo != null) {&#10;            populateRouteDetails(view, routeInfo)&#10;        }&#10;&#10;        // Insert a SupportMapFragment into the map_preview container&#10;        val existing = childFragmentManager.findFragmentById(R.id.map_preview)&#10;        if (existing == null) {&#10;            val mapFragment = SupportMapFragment.newInstance()&#10;            childFragmentManager.beginTransaction()&#10;                .replace(R.id.map_preview, mapFragment)&#10;                .commitNowAllowingStateLoss()&#10;            mapFragment.getMapAsync(this)&#10;        } else if (existing is SupportMapFragment) {&#10;            (existing as SupportMapFragment).getMapAsync(this)&#10;        }&#10;    }&#10;&#10;    override fun onMapReady(map: GoogleMap) {&#10;        googleMap = map&#10;        routePoints?.let { points -&gt;&#10;            if (points.isNotEmpty()) {&#10;                drawRoute(points)&#10;                return&#10;            }&#10;        }&#10;&#10;        // default behavior if no points provided&#10;        val default = LatLng(13.1362, 123.7380)&#10;        googleMap?.addMarker(com.google.android.gms.maps.model.MarkerOptions().position(default).title(&quot;Marker&quot;))&#10;        googleMap?.moveCamera(CameraUpdateFactory.newLatLngZoom(default, 14f))&#10;    }&#10;&#10;    private fun populateRouteDetails(view: View, routeInfo: RouteDetailInfo) {&#10;        val container = view.findViewById&lt;ViewGroup&gt;(R.id.routeStopsContainer) ?: return&#10;        container.removeAllViews()&#10;&#10;&#10;        // Add start stop&#10;        addRouteStopView(container, routeInfo.start, isStart = true, isEnd = false)&#10;&#10;        // Add intermediate stops&#10;        routeInfo.stops.forEach { stop -&gt;&#10;            addRouteStopView(container, stop, isStart = false, isEnd = false)&#10;        }&#10;&#10;        // Add end stop&#10;        addRouteStopView(container, routeInfo.end, isStart = false, isEnd = true)&#10;    }&#10;&#10;    private fun addRouteStopView(container: ViewGroup, stop: RouteStop, isStart: Boolean, isEnd: Boolean) {&#10;        val context = requireContext()&#10;        val stopView = LinearLayout(context).apply {&#10;            orientation = LinearLayout.HORIZONTAL&#10;            layoutParams = ViewGroup.MarginLayoutParams(&#10;                ViewGroup.LayoutParams.MATCH_PARENT,&#10;                ViewGroup.LayoutParams.WRAP_CONTENT&#10;            ).apply {&#10;                bottomMargin = if (isEnd) 4 else 16 // Better spacing between stops&#10;                topMargin = if (isStart) 4 else 0&#10;            }&#10;        }&#10;&#10;        // Dot container with connecting line&#10;        val dotContainer = FrameLayout(context).apply {&#10;            layoutParams = LinearLayout.LayoutParams(40, ViewGroup.LayoutParams.MATCH_PARENT).apply {&#10;                setMargins(0, 0, 20, 0) // More spacing from dot to text&#10;            }&#10;        }&#10;&#10;        // Vertical connecting line (only if not the last stop)&#10;        if (!isEnd) {&#10;            val line = View(context).apply {&#10;                setBackgroundColor(&quot;#3A3D4E&quot;.toColorInt())&#10;                layoutParams = FrameLayout.LayoutParams(3, ViewGroup.LayoutParams.MATCH_PARENT).apply {&#10;                    gravity = android.view.Gravity.CENTER_HORIZONTAL&#10;                    topMargin = 24 // Start line below the dot&#10;                }&#10;            }&#10;            dotContainer.addView(line)&#10;        }&#10;&#10;        // Dot indicator (green for start, red for end, blue for others)&#10;        val dot = View(context).apply {&#10;            val color = when {&#10;                isStart -&gt; &quot;#00E676&quot;.toColorInt()&#10;                isEnd -&gt; &quot;#FF5252&quot;.toColorInt()&#10;                else -&gt; &quot;#4A9FF5&quot;.toColorInt()&#10;            }&#10;            setBackgroundColor(color)&#10;            layoutParams = FrameLayout.LayoutParams(14, 14).apply { // Slightly larger dots&#10;                gravity = android.view.Gravity.CENTER_HORIZONTAL or android.view.Gravity.TOP&#10;                topMargin = 6&#10;            }&#10;            // Make it circular&#10;            outlineProvider = object : android.view.ViewOutlineProvider() {&#10;                override fun getOutline(view: View, outline: android.graphics.Outline) {&#10;                    outline.setOval(0, 0, view.width, view.height)&#10;                }&#10;            }&#10;            clipToOutline = true&#10;        }&#10;&#10;        dotContainer.addView(dot)&#10;&#10;        // Text container&#10;        val textContainer = LinearLayout(context).apply {&#10;            orientation = LinearLayout.VERTICAL&#10;            layoutParams = LinearLayout.LayoutParams(0, ViewGroup.LayoutParams.WRAP_CONTENT, 1f).apply {&#10;                topMargin = 4 // Align text with dot&#10;            }&#10;        }&#10;&#10;        val nameText = TextView(context).apply {&#10;            text = stop.name&#10;            setTextColor(android.graphics.Color.WHITE)&#10;            textSize = 16f // Slightly larger for readability&#10;            setTypeface(typeface, android.graphics.Typeface.BOLD)&#10;            setPadding(0, 2, 0, 2)&#10;        }&#10;&#10;        textContainer.addView(nameText)&#10;&#10;        // ETA badge if present&#10;        if (stop.etaMinutes != null) {&#10;            val etaBadge = TextView(context).apply {&#10;                text = &quot;${stop.etaMinutes} min&quot;&#10;                setTextColor(&quot;#8E9AAF&quot;.toColorInt())&#10;                textSize = 13f&#10;                setPadding(14, 6, 14, 6)&#10;                background = android.graphics.drawable.GradientDrawable().apply {&#10;                    setColor(&quot;#2A2D3E&quot;.toColorInt())&#10;                    cornerRadius = 18f&#10;                }&#10;                layoutParams = LinearLayout.LayoutParams(&#10;                    ViewGroup.LayoutParams.WRAP_CONTENT,&#10;                    ViewGroup.LayoutParams.WRAP_CONTENT&#10;                ).apply {&#10;                    gravity = android.view.Gravity.CENTER_VERTICAL&#10;                    setMargins(12, 0, 0, 0) // Left margin for spacing&#10;                }&#10;            }&#10;            stopView.addView(dotContainer)&#10;            stopView.addView(textContainer)&#10;            stopView.addView(etaBadge)&#10;        } else {&#10;            stopView.addView(dotContainer)&#10;            stopView.addView(textContainer)&#10;        }&#10;&#10;        container.addView(stopView)&#10;    }&#10;&#10;    private fun drawRoute(points: List&lt;LatLng&gt;) {&#10;        val map = googleMap ?: return&#10;&#10;        // clear previous overlays to avoid duplication when opening repeatedly&#10;        map.clear()&#10;&#10;        // main route polyline using centralized config&#10;        val polylineOptions = PolylineOptions()&#10;            .addAll(points)&#10;            .color(RouteRenderConfig.polylineColorHex.toColorInt())&#10;            .width(RouteRenderConfig.polylineWidth)&#10;            .geodesic(true)&#10;&#10;        map.addPolyline(polylineOptions)&#10;&#10;        // Add directional arrow markers along the route if enabled&#10;        if (RouteRenderConfig.showDirectionArrows &amp;&amp; points.size &gt; 1) {&#10;            addDirectionalArrows(map, points)&#10;        }&#10;&#10;        // Optionally add markers depending on the central config&#10;        if (RouteRenderConfig.showMarkers) {&#10;            when (RouteRenderConfig.markerMode) {&#10;                RouteRenderConfig.MarkerMode.NONE -&gt; {&#10;                    // nothing&#10;                }&#10;                RouteRenderConfig.MarkerMode.START_END -&gt; {&#10;                    val start = points.first()&#10;                    val end = points.last()&#10;                    if (RouteRenderConfig.startMarkerResId != null) {&#10;                        map.addMarker(&#10;                            MarkerOptions().position(start).title(&quot;Start&quot;)&#10;                                .icon(com.google.android.gms.maps.model.BitmapDescriptorFactory.fromResource(RouteRenderConfig.startMarkerResId!!))&#10;                        )&#10;                    } else {&#10;                        map.addMarker(&#10;                            MarkerOptions().position(start).title(&quot;Start&quot;)&#10;                                .icon(BitmapDescriptorFactory.defaultMarker(RouteRenderConfig.startMarkerHue))&#10;                        )&#10;                    }&#10;&#10;                    if (RouteRenderConfig.endMarkerResId != null) {&#10;                        map.addMarker(&#10;                            MarkerOptions().position(end).title(&quot;End&quot;)&#10;                                .icon(com.google.android.gms.maps.model.BitmapDescriptorFactory.fromResource(RouteRenderConfig.endMarkerResId!!))&#10;                        )&#10;                    } else {&#10;                        map.addMarker(&#10;                            MarkerOptions().position(end).title(&quot;End&quot;)&#10;                                .icon(BitmapDescriptorFactory.defaultMarker(RouteRenderConfig.endMarkerHue))&#10;                        )&#10;                    }&#10;                }&#10;                RouteRenderConfig.MarkerMode.ALL_NUMBERED -&gt; {&#10;                    // Add markers for all stops (simple colored markers)&#10;                    for (i in points.indices) {&#10;                        val pos = points[i]&#10;                        if (RouteRenderConfig.intermediateMarkerResId != null) {&#10;                            map.addMarker(&#10;                                MarkerOptions().position(pos).title(&quot;Stop ${i + 1}&quot;)&#10;                                    .icon(com.google.android.gms.maps.model.BitmapDescriptorFactory.fromResource(RouteRenderConfig.intermediateMarkerResId!!))&#10;                            )&#10;                        } else {&#10;                            // use hue: start gets start hue, end gets end hue, intermediates get intermediateHue&#10;                            val hue = when (i) {&#10;                                0 -&gt; RouteRenderConfig.startMarkerHue&#10;                                points.size - 1 -&gt; RouteRenderConfig.endMarkerHue&#10;                                else -&gt; RouteRenderConfig.intermediateMarkerHue&#10;                            }&#10;                            map.addMarker(&#10;                                MarkerOptions().position(pos).title(&quot;Stop ${i + 1}&quot;)&#10;                                    .icon(BitmapDescriptorFactory.defaultMarker(hue))&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Build camera bounds so the whole route fits nicely with padding&#10;        val boundsBuilder = LatLngBounds.builder()&#10;        points.forEach { boundsBuilder.include(it) }&#10;        val bounds = boundsBuilder.build()&#10;        // Slightly larger padding for the small preview card so markers and route aren't cut off&#10;        map.animateCamera(CameraUpdateFactory.newLatLngBounds(bounds, 160))&#10;&#10;        // Improve map UI for preview: hide map toolbar and allow gestures&#10;        map.uiSettings.isMapToolbarEnabled = false&#10;        map.uiSettings.setAllGesturesEnabled(true)&#10;    }&#10;&#10;    private fun addDirectionalArrows(map: GoogleMap, points: List&lt;LatLng&gt;) {&#10;        // Add arrow markers at regular intervals to show direction&#10;        val arrowInterval = points.size / 15 // Show about 15 arrows along the route&#10;        if (arrowInterval &lt; 2) return&#10;&#10;        // Create a larger, more prominent arrow icon&#10;        val arrowIcon = createArrowBitmap()&#10;&#10;        for (i in arrowInterval until points.size step arrowInterval) {&#10;            if (i &gt;= points.size - 1) break&#10;&#10;            val point = points[i]&#10;            val nextPoint = points[i + 1]&#10;&#10;            // Calculate bearing (direction) between consecutive points&#10;            val bearing = calculateBearing(point, nextPoint)&#10;&#10;            // Create a larger arrow marker rotated in the direction of travel&#10;            val markerOptions = MarkerOptions()&#10;                .position(point)&#10;                .rotation(bearing)&#10;                .anchor(0.5f, 0.5f)&#10;                .flat(true)&#10;                .icon(arrowIcon)&#10;                .zIndex(10f) // Place arrows above the route line&#10;&#10;            map.addMarker(markerOptions)&#10;        }&#10;    }&#10;&#10;    private fun createArrowBitmap(): com.google.android.gms.maps.model.BitmapDescriptor {&#10;        val size = 100&#10;        val bitmap = android.graphics.Bitmap.createBitmap(size, size, android.graphics.Bitmap.Config.ARGB_8888)&#10;        val canvas = android.graphics.Canvas(bitmap)&#10;&#10;        val paint = android.graphics.Paint().apply {&#10;            isAntiAlias = true&#10;            style = android.graphics.Paint.Style.FILL&#10;        }&#10;&#10;        // Draw arrow body (white/light interior)&#10;        paint.color = android.graphics.Color.parseColor(&quot;#FFFFFF&quot;)&#10;        val bodyPath = android.graphics.Path().apply {&#10;            moveTo(size / 2f, size * 0.25f)&#10;            lineTo(size * 0.65f, size * 0.5f)&#10;            lineTo(size * 0.55f, size * 0.5f)&#10;            lineTo(size * 0.55f, size * 0.75f)&#10;            lineTo(size * 0.45f, size * 0.75f)&#10;            lineTo(size * 0.45f, size * 0.5f)&#10;            lineTo(size * 0.35f, size * 0.5f)&#10;            close()&#10;        }&#10;        canvas.drawPath(bodyPath, paint)&#10;&#10;        // Draw arrow tip (orange)&#10;        paint.color = android.graphics.Color.parseColor(&quot;#FF9800&quot;)&#10;        val tipPath = android.graphics.Path().apply {&#10;            moveTo(size / 2f, size * 0.25f)&#10;            lineTo(size * 0.65f, size * 0.5f)&#10;            lineTo(size * 0.35f, size * 0.5f)&#10;            close()&#10;        }&#10;        canvas.drawPath(tipPath, paint)&#10;&#10;        return BitmapDescriptorFactory.fromBitmap(bitmap)&#10;    }&#10;&#10;    private fun calculateBearing(start: LatLng, end: LatLng): Float {&#10;        val lat1 = Math.toRadians(start.latitude)&#10;        val lat2 = Math.toRadians(end.latitude)&#10;        val lonDiff = Math.toRadians(end.longitude - start.longitude)&#10;&#10;        val y = Math.sin(lonDiff) * Math.cos(lat2)&#10;        val x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(lonDiff)&#10;&#10;        val bearing = Math.toDegrees(Math.atan2(y, x))&#10;        return ((bearing + 360) % 360).toFloat()&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.aginavigation.ui.routes&#10;&#10;import android.os.Bundle&#10;import android.view.LayoutInflater&#10;import android.view.View&#10;import android.view.ViewGroup&#10;import android.widget.Button&#10;import android.widget.ImageButton&#10;import android.widget.TextView&#10;import android.widget.LinearLayout&#10;import android.widget.FrameLayout&#10;import androidx.fragment.app.Fragment&#10;import androidx.navigation.fragment.findNavController&#10;import com.example.aginavigation.R&#10;import com.example.aginavigation.data.RouteRenderConfig&#10;import com.google.android.gms.maps.CameraUpdateFactory&#10;import com.google.android.gms.maps.GoogleMap&#10;import com.google.android.gms.maps.OnMapReadyCallback&#10;import com.google.android.gms.maps.SupportMapFragment&#10;import com.google.android.gms.maps.model.BitmapDescriptorFactory&#10;import com.google.android.gms.maps.model.LatLng&#10;import com.google.android.gms.maps.model.LatLngBounds&#10;import com.google.android.gms.maps.model.MarkerOptions&#10;import com.google.android.gms.maps.model.PolylineOptions&#10;import androidx.core.graphics.toColorInt&#10;import kotlin.math.max&#10;&#10;class RouteDetailFragment : Fragment(), OnMapReadyCallback {&#10;&#10;    private var googleMap: GoogleMap? = null&#10;    private var routePoints: ArrayList&lt;LatLng&gt;? = null&#10;&#10;    override fun onCreateView(&#10;        inflater: LayoutInflater,&#10;        container: ViewGroup?,&#10;        savedInstanceState: Bundle?&#10;    ): View? {&#10;        return inflater.inflate(R.layout.fragment_route_detail, container, false)&#10;    }&#10;&#10;    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {&#10;        super.onViewCreated(view, savedInstanceState)&#10;&#10;&#10;        val btnBack: ImageButton = view.findViewById(R.id.btnBack)&#10;        btnBack.setOnClickListener { findNavController().navigateUp() }&#10;&#10;        val btnStart: Button = view.findViewById(R.id.btnStartNavigation)&#10;        btnStart.setOnClickListener {&#10;            // Placeholder - start navigation later&#10;            findNavController().navigateUp()&#10;        }&#10;&#10;        // Retrieve route points if provided&#10;        @Suppress(&quot;DEPRECATION&quot;)&#10;        routePoints = arguments?.getParcelableArrayList(&quot;route_points&quot;)&#10;&#10;        val btnViewFull: Button? = view.findViewById(R.id.btnViewFullMap)&#10;        btnViewFull?.setOnClickListener {&#10;            // Open the fullscreen MapFragment and pass the same points&#10;            val bundle = Bundle().apply { putParcelableArrayList(&quot;route_points&quot;, routePoints) }&#10;            findNavController().navigate(R.id.navigation_map, bundle)&#10;        }&#10;&#10;        // Retrieve and display route name, summary and fare&#10;        val routeName = arguments?.getString(&quot;destinationName&quot;)&#10;        val routeSummary = arguments?.getString(&quot;routeSummary&quot;)&#10;        val routeFare = arguments?.getString(&quot;routeFare&quot;)&#10;&#10;        // Update the UI with route information&#10;        view.findViewById&lt;TextView&gt;(R.id.tvRouteName)?.text = routeName ?: &quot;Route Details&quot;&#10;        view.findViewById&lt;TextView&gt;(R.id.tvSummary)?.text = routeSummary ?: &quot;No description available&quot;&#10;        view.findViewById&lt;TextView&gt;(R.id.tvFareValue)?.text = routeFare ?: &quot;N/A&quot;&#10;&#10;        // Retrieve and display route detail info if available&#10;        @Suppress(&quot;DEPRECATION&quot;)&#10;        val routeInfo = arguments?.getSerializable(&quot;route_detail_info&quot;) as? RouteDetailInfo&#10;        if (routeInfo != null) {&#10;            populateRouteDetails(view, routeInfo)&#10;        }&#10;&#10;        // Insert a SupportMapFragment into the map_preview container&#10;        val existing = childFragmentManager.findFragmentById(R.id.map_preview)&#10;        if (existing == null) {&#10;            val mapFragment = SupportMapFragment.newInstance()&#10;            childFragmentManager.beginTransaction()&#10;                .replace(R.id.map_preview, mapFragment)&#10;                .commitNowAllowingStateLoss()&#10;            mapFragment.getMapAsync(this)&#10;        } else if (existing is SupportMapFragment) {&#10;            (existing as SupportMapFragment).getMapAsync(this)&#10;        }&#10;    }&#10;&#10;    override fun onMapReady(map: GoogleMap) {&#10;        googleMap = map&#10;        routePoints?.let { points -&gt;&#10;            if (points.isNotEmpty()) {&#10;                drawRoute(points)&#10;                return&#10;            }&#10;        }&#10;&#10;        // default behavior if no points provided&#10;        val default = LatLng(13.1362, 123.7380)&#10;        googleMap?.addMarker(com.google.android.gms.maps.model.MarkerOptions().position(default).title(&quot;Marker&quot;))&#10;        googleMap?.moveCamera(CameraUpdateFactory.newLatLngZoom(default, 14f))&#10;    }&#10;&#10;    private fun populateRouteDetails(view: View, routeInfo: RouteDetailInfo) {&#10;        val container = view.findViewById&lt;ViewGroup&gt;(R.id.routeStopsContainer) ?: return&#10;        container.removeAllViews()&#10;&#10;&#10;        // Add start stop&#10;        addRouteStopView(container, routeInfo.start, isStart = true, isEnd = false)&#10;&#10;        // Add intermediate stops&#10;        routeInfo.stops.forEach { stop -&gt;&#10;            addRouteStopView(container, stop, isStart = false, isEnd = false)&#10;        }&#10;&#10;        // Add end stop&#10;        addRouteStopView(container, routeInfo.end, isStart = false, isEnd = true)&#10;    }&#10;&#10;    private fun addRouteStopView(container: ViewGroup, stop: RouteStop, isStart: Boolean, isEnd: Boolean) {&#10;        val context = requireContext()&#10;        val stopView = LinearLayout(context).apply {&#10;            orientation = LinearLayout.HORIZONTAL&#10;            layoutParams = ViewGroup.MarginLayoutParams(&#10;                ViewGroup.LayoutParams.MATCH_PARENT,&#10;                ViewGroup.LayoutParams.WRAP_CONTENT&#10;            ).apply {&#10;                bottomMargin = if (isEnd) 4 else 16 // Better spacing between stops&#10;                topMargin = if (isStart) 4 else 0&#10;            }&#10;        }&#10;&#10;        // Dot container with connecting line&#10;        val dotContainer = FrameLayout(context).apply {&#10;            layoutParams = LinearLayout.LayoutParams(40, ViewGroup.LayoutParams.MATCH_PARENT).apply {&#10;                setMargins(0, 0, 20, 0) // More spacing from dot to text&#10;            }&#10;        }&#10;&#10;        // Vertical connecting line (only if not the last stop)&#10;        if (!isEnd) {&#10;            val line = View(context).apply {&#10;                setBackgroundColor(&quot;#3A3D4E&quot;.toColorInt())&#10;                layoutParams = FrameLayout.LayoutParams(3, ViewGroup.LayoutParams.MATCH_PARENT).apply {&#10;                    gravity = android.view.Gravity.CENTER_HORIZONTAL&#10;                    topMargin = 24 // Start line below the dot&#10;                }&#10;            }&#10;            dotContainer.addView(line)&#10;        }&#10;&#10;        // Dot indicator (green for start, red for end, blue for others)&#10;        val dot = View(context).apply {&#10;            val color = when {&#10;                isStart -&gt; &quot;#00E676&quot;.toColorInt()&#10;                isEnd -&gt; &quot;#FF5252&quot;.toColorInt()&#10;                else -&gt; &quot;#4A9FF5&quot;.toColorInt()&#10;            }&#10;            setBackgroundColor(color)&#10;            layoutParams = FrameLayout.LayoutParams(14, 14).apply { // Slightly larger dots&#10;                gravity = android.view.Gravity.CENTER_HORIZONTAL or android.view.Gravity.TOP&#10;                topMargin = 6&#10;            }&#10;            // Make it circular&#10;            outlineProvider = object : android.view.ViewOutlineProvider() {&#10;                override fun getOutline(view: View, outline: android.graphics.Outline) {&#10;                    outline.setOval(0, 0, view.width, view.height)&#10;                }&#10;            }&#10;            clipToOutline = true&#10;        }&#10;&#10;        dotContainer.addView(dot)&#10;&#10;        // Text container&#10;        val textContainer = LinearLayout(context).apply {&#10;            orientation = LinearLayout.VERTICAL&#10;            layoutParams = LinearLayout.LayoutParams(0, ViewGroup.LayoutParams.WRAP_CONTENT, 1f).apply {&#10;                topMargin = 4 // Align text with dot&#10;            }&#10;        }&#10;&#10;        val nameText = TextView(context).apply {&#10;            text = stop.name&#10;            setTextColor(android.graphics.Color.WHITE)&#10;            textSize = 16f // Slightly larger for readability&#10;            setTypeface(typeface, android.graphics.Typeface.BOLD)&#10;            setPadding(0, 2, 0, 2)&#10;        }&#10;&#10;        textContainer.addView(nameText)&#10;&#10;        // ETA badge if present&#10;        if (stop.etaMinutes != null) {&#10;            val etaBadge = TextView(context).apply {&#10;                text = &quot;${stop.etaMinutes} min&quot;&#10;                setTextColor(&quot;#8E9AAF&quot;.toColorInt())&#10;                textSize = 13f&#10;                setPadding(14, 6, 14, 6)&#10;                background = android.graphics.drawable.GradientDrawable().apply {&#10;                    setColor(&quot;#2A2D3E&quot;.toColorInt())&#10;                    cornerRadius = 18f&#10;                }&#10;                layoutParams = LinearLayout.LayoutParams(&#10;                    ViewGroup.LayoutParams.WRAP_CONTENT,&#10;                    ViewGroup.LayoutParams.WRAP_CONTENT&#10;                ).apply {&#10;                    gravity = android.view.Gravity.CENTER_VERTICAL&#10;                    setMargins(12, 0, 0, 0) // Left margin for spacing&#10;                }&#10;            }&#10;            stopView.addView(dotContainer)&#10;            stopView.addView(textContainer)&#10;            stopView.addView(etaBadge)&#10;        } else {&#10;            stopView.addView(dotContainer)&#10;            stopView.addView(textContainer)&#10;        }&#10;&#10;        container.addView(stopView)&#10;    }&#10;&#10;    private fun drawRoute(points: List&lt;LatLng&gt;) {&#10;        val map = googleMap ?: return&#10;&#10;        // clear previous overlays to avoid duplication when opening repeatedly&#10;        map.clear()&#10;&#10;        // main route polyline using centralized config&#10;        val polylineOptions = PolylineOptions()&#10;            .addAll(points)&#10;            .color(RouteRenderConfig.polylineColorHex.toColorInt())&#10;            .width(RouteRenderConfig.polylineWidth)&#10;            .geodesic(true)&#10;&#10;        map.addPolyline(polylineOptions)&#10;&#10;        // Add directional arrow markers along the route if enabled&#10;        if (RouteRenderConfig.showDirectionArrows &amp;&amp; points.size &gt; 1) {&#10;            addDirectionalArrows(map, points)&#10;        }&#10;&#10;        // Optionally add markers depending on the central config&#10;        if (RouteRenderConfig.showMarkers) {&#10;            when (RouteRenderConfig.markerMode) {&#10;                RouteRenderConfig.MarkerMode.NONE -&gt; {&#10;                    // nothing&#10;                }&#10;                RouteRenderConfig.MarkerMode.START_END -&gt; {&#10;                    val start = points.first()&#10;                    val end = points.last()&#10;                    if (RouteRenderConfig.startMarkerResId != null) {&#10;                        map.addMarker(&#10;                            MarkerOptions().position(start).title(&quot;Start&quot;)&#10;                                .icon(com.google.android.gms.maps.model.BitmapDescriptorFactory.fromResource(RouteRenderConfig.startMarkerResId!!))&#10;                        )&#10;                    } else {&#10;                        map.addMarker(&#10;                            MarkerOptions().position(start).title(&quot;Start&quot;)&#10;                                .icon(BitmapDescriptorFactory.defaultMarker(RouteRenderConfig.startMarkerHue))&#10;                        )&#10;                    }&#10;&#10;                    if (RouteRenderConfig.endMarkerResId != null) {&#10;                        map.addMarker(&#10;                            MarkerOptions().position(end).title(&quot;End&quot;)&#10;                                .icon(com.google.android.gms.maps.model.BitmapDescriptorFactory.fromResource(RouteRenderConfig.endMarkerResId!!))&#10;                        )&#10;                    } else {&#10;                        map.addMarker(&#10;                            MarkerOptions().position(end).title(&quot;End&quot;)&#10;                                .icon(BitmapDescriptorFactory.defaultMarker(RouteRenderConfig.endMarkerHue))&#10;                        )&#10;                    }&#10;                }&#10;                RouteRenderConfig.MarkerMode.ALL_NUMBERED -&gt; {&#10;                    // Add markers for all stops (simple colored markers)&#10;                    for (i in points.indices) {&#10;                        val pos = points[i]&#10;                        if (RouteRenderConfig.intermediateMarkerResId != null) {&#10;                            map.addMarker(&#10;                                MarkerOptions().position(pos).title(&quot;Stop ${i + 1}&quot;)&#10;                                    .icon(com.google.android.gms.maps.model.BitmapDescriptorFactory.fromResource(RouteRenderConfig.intermediateMarkerResId!!))&#10;                            )&#10;                        } else {&#10;                            // use hue: start gets start hue, end gets end hue, intermediates get intermediateHue&#10;                            val hue = when (i) {&#10;                                0 -&gt; RouteRenderConfig.startMarkerHue&#10;                                points.size - 1 -&gt; RouteRenderConfig.endMarkerHue&#10;                                else -&gt; RouteRenderConfig.intermediateMarkerHue&#10;                            }&#10;                            map.addMarker(&#10;                                MarkerOptions().position(pos).title(&quot;Stop ${i + 1}&quot;)&#10;                                    .icon(BitmapDescriptorFactory.defaultMarker(hue))&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Build camera bounds so the whole route fits nicely with padding&#10;        val boundsBuilder = LatLngBounds.builder()&#10;        points.forEach { boundsBuilder.include(it) }&#10;        val bounds = boundsBuilder.build()&#10;        // Slightly larger padding for the small preview card so markers and route aren't cut off&#10;        map.animateCamera(CameraUpdateFactory.newLatLngBounds(bounds, 160))&#10;&#10;        // Improve map UI for preview: hide map toolbar and allow gestures&#10;        map.uiSettings.isMapToolbarEnabled = false&#10;        map.uiSettings.setAllGesturesEnabled(true)&#10;    }&#10;&#10;    private fun addDirectionalArrows(map: GoogleMap, points: List&lt;LatLng&gt;) {&#10;        // Show roughly 10-12 arrows along the route; ensure at least one every 2 points&#10;        val desiredArrows = 12&#10;        val arrowInterval = max(2, points.size / desiredArrows)&#10;&#10;        // Create a skinnier, more prominent arrow icon (keeps rotation capability)&#10;        val arrowIcon = createArrowBitmap()&#10;&#10;        var i = arrowInterval&#10;        while (i &lt; points.size - 1) {&#10;            val point = points[i]&#10;            val nextPoint = points[i + 1]&#10;&#10;            val bearing = calculateBearing(point, nextPoint)&#10;&#10;            val markerOptions = MarkerOptions()&#10;                .position(point)&#10;                .rotation(bearing)&#10;                .anchor(0.5f, 0.5f)&#10;                .flat(true)&#10;                .icon(arrowIcon)&#10;                .zIndex(10f)&#10;&#10;            map.addMarker(markerOptions)&#10;&#10;            i += arrowInterval&#10;        }&#10;    }&#10;&#10;    private fun createArrowBitmap(): com.google.android.gms.maps.model.BitmapDescriptor {&#10;        // Larger canvas so the arrow stays crisp when rendered on map at various zooms&#10;        val size = 140&#10;        val bitmap = android.graphics.Bitmap.createBitmap(size, size, android.graphics.Bitmap.Config.ARGB_8888)&#10;        val canvas = android.graphics.Canvas(bitmap)&#10;&#10;        // Paint for gradient body&#10;        val bodyPaint = android.graphics.Paint().apply {&#10;            isAntiAlias = true&#10;            style = android.graphics.Paint.Style.FILL&#10;        }&#10;&#10;        // Gradient from lighter orange to darker reddish-orange along the arrow length&#10;        val gradient = android.graphics.LinearGradient(&#10;            0f, 0f, size.toFloat(), size.toFloat(),&#10;            intArrayOf(android.graphics.Color.parseColor(&quot;#FFD07A&quot;), android.graphics.Color.parseColor(&quot;#E64A19&quot;)),&#10;            null,&#10;            android.graphics.Shader.TileMode.CLAMP&#10;        )&#10;        bodyPaint.shader = gradient&#10;&#10;        // Draw a skinnier arrow shape pointing up in bitmap coordinate space (we rotate the marker later)&#10;        val bodyPath = android.graphics.Path().apply {&#10;            val cx = size / 2f&#10;            // tip near the top&#10;            moveTo(cx, size * 0.18f)&#10;            // right edge of tip&#10;            lineTo(size * 0.74f, size * 0.5f)&#10;            // slimming the shaft&#10;            lineTo(size * 0.56f, size * 0.5f)&#10;            lineTo(size * 0.56f, size * 0.82f)&#10;            lineTo(size * 0.44f, size * 0.82f)&#10;            lineTo(size * 0.44f, size * 0.5f)&#10;            lineTo(size * 0.26f, size * 0.5f)&#10;            close()&#10;        }&#10;        canvas.drawPath(bodyPath, bodyPaint)&#10;&#10;        // Draw inner white inset to give a two-tone look (white center)&#10;        val innerPaint = android.graphics.Paint().apply {&#10;            isAntiAlias = true&#10;            style = android.graphics.Paint.Style.FILL&#10;            color = android.graphics.Color.parseColor(&quot;#FFFFFF&quot;)&#10;        }&#10;&#10;        val innerPath = android.graphics.Path().apply {&#10;            val cx = size / 2f&#10;            moveTo(cx, size * 0.26f)&#10;            lineTo(size * 0.66f, size * 0.5f)&#10;            lineTo(size * 0.5f, size * 0.5f)&#10;            lineTo(size * 0.5f, size * 0.74f)&#10;            lineTo(size * 0.5f, size * 0.74f)&#10;            lineTo(size * 0.5f, size * 0.5f)&#10;            lineTo(size * 0.34f, size * 0.5f)&#10;            close()&#10;        }&#10;        canvas.drawPath(innerPath, innerPaint)&#10;&#10;        // Add a subtle darker outline to improve contrast on map&#10;        val strokePaint = android.graphics.Paint().apply {&#10;            isAntiAlias = true&#10;            style = android.graphics.Paint.Style.STROKE&#10;            strokeWidth = 2f&#10;            color = android.graphics.Color.parseColor(&quot;#BF360C&quot;) // dark reddish outline&#10;        }&#10;        canvas.drawPath(bodyPath, strokePaint)&#10;&#10;        return BitmapDescriptorFactory.fromBitmap(bitmap)&#10;    }&#10;&#10;    private fun calculateBearing(start: LatLng, end: LatLng): Float {&#10;        val lat1 = Math.toRadians(start.latitude)&#10;        val lat2 = Math.toRadians(end.latitude)&#10;        val lonDiff = Math.toRadians(end.longitude - start.longitude)&#10;&#10;        val y = Math.sin(lonDiff) * Math.cos(lat2)&#10;        val x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(lonDiff)&#10;&#10;        val bearing = Math.toDegrees(Math.atan2(y, x))&#10;        return ((bearing + 360) % 360).toFloat()&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>